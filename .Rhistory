library(foreign)
library(tidyverse)
epilepsy <- read.dta("epilepsy.dta")
#convert data from wide to long
longep=pivot_longer(epilepsy, cols=c("y0", "y1", "y2", "y3", "y4"))
longep=rename(longep, number=value)
longep=rename(longep, year=name)
#full model
library(geepack)
model1 <- geeglm(number ~ factor(trt) + factor(year)+ factor(trt)*factor(year), data=longep, id = id, waves=longep$year, family=poisson(link="log"),
corstr=("unstructured"))
summary(model1)
#change year to integer
longep$year=ifelse(longep$year=="y0", 0, longep$year)
longep$year=ifelse(longep$year=="y1", 1, longep$year)
longep$year=ifelse(longep$year=="y2", 2, longep$year)
longep$year=ifelse(longep$year=="y3", 3, longep$year)
longep$year=ifelse(longep$year=="y4", 4, longep$year)
#reduced model
model2 <- geeglm(number ~ factor(year), data=longep,
id = id, waves=longep$year, family=poisson(link="log"),
corstr=("unstructured"))
summary(model2)
#create Ptime variable
longep$Ptime<-ifelse(longep$year=="0", 0, 1)
#model
library(geepack)
longep
model3 <- geeglm(number ~ factor(trt)*factor(Ptime)+ factor(trt)*factor(Ptime), data=longep, id = id, waves=as.integer(longep$Ptime), family=poisson(link="log"), corstr=("unstructured"))
Rcpp::sourceCpp("Desktop/Untitled.cpp")
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
options(warn = -1)
install.packages("/Users/mengbing/Dropbox (University of Michigan)/from_box/research/tree_multivariate_binary/ddtlcm_0.1.0.tar.gz", repos = NULL, type="source")
library(poLCA)
library(phylobase)
library(ape)
library(data.table)
library(ggplot2)
library(parallel)
library(BayesLogit)
library(truncnorm)
library(Matrix)
library(matrixStats)
library(extraDistr)
# source("/Users/mengbing/Dropbox (University of Michigan)/from_box/research/tree_multivariate_binary/ddtlcm_package/R/loglikehoods.R")
# source("/Users/mengbing/Dropbox (University of Michigan)/from_box/research/tree_multivariate_binary/ddtlcm_package/R/utils.R")
# source("/Users/mengbing/Dropbox (University of Michigan)/from_box/research/tree_multivariate_binary/ddtlcm_package/R/MH_tree.R")
# source("/Users/mengbing/Dropbox (University of Michigan)/from_box/research/tree_multivariate_binary/ddtlcm_package/R/initialization.R")
# source("/Users/mengbing/Dropbox (University of Michigan)/from_box/research/tree_multivariate_binary/ddtlcm_package/R/Gibbs_lcm.R")
# source("/Users/mengbing/Dropbox (University of Michigan)/from_box/research/tree_multivariate_binary/ddtlcm_package/R/ddtlcm_fit.R")
# source("/Users/mengbing/Dropbox (University of Michigan)/from_box/research/tree_multivariate_binary/ddtlcm_package/R/summary_functions.R")
# source("/Users/mengbing/Dropbox (University of Michigan)/from_box/research/tree_multivariate_binary/ddtlcm_package/R/simulate_DDT_functions.R")
# library(ddtlcm)
load("../hchs_simulated_data/hchs_simulated_data.RData")
# extract the reponse matrix
response_matrix <- sim_data$response_matrix
# number of individuals
N <- dim(response_matrix)[1]
# number of pre-defined major food groups
G <- length(num_items_per_group)
# total number of items. Equals to the number of columns of sim_data$response_matrix
J <- sum(num_items_per_group)
item_group_membership <- rep(1:G, num_items_per_group)
# a list of item group membership indices of columns of data
item_membership_list <- list()
for (g in 1:G) {
item_membership_list[[g]] <- which(item_group_membership == g)
}
rm(item_group_membership)
# dimension of the simulated response matrix
cat("N =", N, ", J =", J)
library(ddtlcm)
library(rstan)
library(devtools)
devtools::install_github("smwu/baysc"
)
install.packages("rstantools")
devtools::install_github("smwu/baysc")
install.packages("rstan")
install.packages("rstan")
remove.packages(c("StanHeaders", "rstan"))
install.packages("rstan")
devtools::install_github("smwu/baysc")
remove.packages("Rcpp")
remove.packages("Rcpp", lib="/Library/Frameworks/R.framework/Versions/4.2/Resources/miworkspace-library")
remove.packages("Rcpp", lib="/Library/Frameworks/R.framework/Versions/4.2/Resources/miworkspace-library")
install.packages("Rcpp")
install.packages("Rcpp")
install.packages("Rcpp")
remove.packages("RcppArmadillo")
remove.packages("RcppArmadillo", lib="/Library/Frameworks/R.framework/Versions/4.2/Resources/miworkspace-library")
install.packages("RcppArmadillo")
library(RcppEigen)
install.packages("RcppEigen")
devtools::install_github("smwu/baysc")
library(baysc)
data("data_nhanes")
force(data_nhanes)
x_mat <- data_nhanes[, c("citrus", "oth_fruit", "fruit_juice", "dark_green", "tomatoes", "oth_red", "potatoes", "oth_starchy", "oth_veg", "whole_grain", "ref_grain", "meat", "cured_meats", "organ", "poultry", "seafood_high", "seafood_low", "eggs", "soybean", "nuts", "leg_protein", "milk", "yogurt", "cheese", "oils", "solid_fats", "add_sugars", "drinks")]
x_mat <- as.matrix(x_mat)
y_all <- data_nhanes$BP_flag
library(baysc)
data("data_nhanes")
x_mat <- data_nhanes[, c("citrus", "oth_fruit", "fruit_juice", "dark_green", "tomatoes", "oth_red", "potatoes", "oth_starchy", "oth_veg", "whole_grain", "ref_grain", "meat", "cured_meats", "organ", "poultry", "seafood_high", "seafood_low", "eggs", "soybean", "nuts", "leg_protein", "milk", "yogurt", "cheese", "oils", "solid_fats", "add_sugars", "drinks")]
x_mat <- as.matrix(x_mat)
y_all <- data_nhanes$BP_flag
# Survey stratum indicators
stratum_id <- data_nhanes$stratum_id
# Survey cluster indicators
cluster_id <- data_nhanes$cluster_id
# Survey sampling weights
sampling_wt <- data_nhanes$sample_wt
# Create dataframe of additional confounders
V_data <- data_nhanes %>% select(age_cat, racethnic, smoker, physactive)
library(dplyr)
data("data_nhanes")
x_mat <- data_nhanes[, c("citrus", "oth_fruit", "fruit_juice", "dark_green", "tomatoes", "oth_red", "potatoes", "oth_starchy", "oth_veg", "whole_grain", "ref_grain", "meat", "cured_meats", "organ", "poultry", "seafood_high", "seafood_low", "eggs", "soybean", "nuts", "leg_protein", "milk", "yogurt", "cheese", "oils", "solid_fats", "add_sugars", "drinks")]
x_mat <- as.matrix(x_mat)
y_all <- data_nhanes$BP_flag
# Survey stratum indicators
stratum_id <- data_nhanes$stratum_id
# Survey cluster indicators
cluster_id <- data_nhanes$cluster_id
# Survey sampling weights
sampling_wt <- data_nhanes$sample_wt
# Create dataframe of additional confounders
V_data <- data_nhanes %>% select(age_cat, racethnic, smoker, physactive)
# Regression formula for additional confounders
glm_form <- "~ age_cat + racethnic + smoker + physactive"
# Run SWOLCA
res_swolca <- swolca(x_mat = x_mat, y_all = y_all, V_data = V_data,
glm_form = glm_form, sampling_wt = sampling_wt,
cluster_id = cluster_id, stratum_id = stratum_id,
run_sampler = "both", adapt_seed = 888, n_runs = 300,
burn = 150, thin = 3, update = 20, save_res = FALSE)
# Run SWOLCA
res_swolca <- swolca(x_mat = x_mat, y_all = y_all, V_data = V_data,
glm_form = glm_form, sampling_wt = sampling_wt,
cluster_id = cluster_id, stratum_id = stratum_id,
run_sampler = "both", adapt_seed = 888, n_runs = 300,
burn = 150, thin = 3, update = 20, save_res = FALSE)
# Apply variance adjustment
res_swolca_adjust <- swolca_var_adjust(res = res_swolca, adjust_seed = 888,
num_reps = 100, save_res = FALSE)
res_swolca_adjust
summary(res_swolca_adjust)
plot_pattern_profiles(res = res_swolca_adjust)
regr_coefs <- get_regr_coefs(res = res_swolca_adjust, ci_level = 0.95, digits = 2)
plot_regr_coefs(regr_coefs = regr_coefs, res = res_swolca_adjust)
class(res_swolca)
summary.swolca <- function(x){
mean(res_swolca$estimates)
}
summary(res_swolca)
summary.swolca <- function(x){
mean(res_swolca$estimates, na.rm = TRUE)
}
summary(res_swolca)
summary.swolca <- function(x){
mean(res_swolca$estimates$theta_red, na.rm = TRUE)
}
summary(res_swolca)
?sample.int
set.seed(40)
N=5*10
x <- matrix(sample.int(2), nrow = 5, ncol = 10)
heatmap(x)
x
image(x)
image(t(x))
image(t(x), xaxt= "n", yaxt= "n", col = c("blue", "gold"))
axis(side=1, at = seq(0, 10, by=1), labels = paste0("Item ", 1:10), xpd=NA)
image(t(x), xaxt= "n", yaxt= "n", col = c("blue", "gold"))
axis(side=1, at = seq(1, 10, by=1), labels = paste0("Item ", 1:10), xpd=NA)
image(t(x), xaxt= "n", yaxt= "n", col = c("blue", "gold"))
axis(side=1, labels = paste0("Item ", 1:10), xpd=NA)
image(t(x), yaxt= "n", col = c("blue", "gold"))
seq(0, 1, by=0.1)
image(t(x), xaxt= "n", yaxt= "n", col = c("blue", "gold"))
axis(side=1, at = seq(0.1, 1, by=0.1), labels = paste0("Item ", 1:10), xpd=NA)
?seq
image(t(x), xaxt= "n", yaxt= "n", col = c("blue", "gold"))
axis(side=1, at = seq(0, 1, length.out = 10), labels = paste0("Item ", 1:10), xpd=NA)
image(t(x), xaxt= "n", yaxt= "n", col = c("blue", "gold"))
axis(side=1, at = seq(0, 1, length.out = 10), labels = paste0("Item ", 1:10), xpd=NA, cex = 1.5)
image(t(x), xaxt= "n", col = c("blue", "gold"))
image(t(x), xaxt= "n", yaxt= "n", col = c("blue", "gold"), cex = 1.5)
axis(side=1, at = seq(0, 1, length.out = 10), labels = paste0("Item ", 1:10), xpd=NA, cex = 1.5)
axis(side=2, at = seq(0, 1, length.out = 5), labels = paste0("Individual ", 1:5), xpd=NA, cex = 1.5)
image(t(x), xaxt= "n", yaxt= "n", col = c("blue", "gold"), cex = 1.5)
axis(side=1, at = seq(0, 1, length.out = 10), labels = paste0("Item ", 1:10), xpd=NA, cex = 1.5)
axis(side=2, at = seq(0, 1, length.out = 5), labels = paste0("Individual ", 1:5), xpd=NA, cex = 1.5, las = 2)
image(t(x), xaxt= "n", yaxt= "n", col = c("blue", "gold"), cex = 1.5)
axis(side=1, at = seq(0, 1, length.out = 10), labels = paste0("Item ", 1:10), xpd=NA, cex = 1.5)
axis(side=2, at = seq(0, 1, length.out = 5), labels = paste0("i = ", 1:5), xpd=NA, cex = 1.5, las = 2
)
setwd("/Users/mengbing/Dropbox (University of Michigan)/from_box/research/R_packages/ddtlcm")
library(roxygen2)
devtools::document()
devtools::document()
devtools::check(args = "--as-cran")
devtools::check(args = "--as-cran")
devtools::check(args = "--as-cran")
devtools::check(args = "--as-cran")
devtools::build()
?ddtlcm_fit
?ddtlcm_fit
devtools::build()
###############################################################
#' MH-within-Gibbs sampler to sample from the full posterior
#' distribution of DDT-LCM
###############################################################
library("roxygen2")
out <- roc_proc_text(rd_roclet(), "
#' @description Use DDT-LCM to estimate latent class and tree on class profiles for
#'  multivariate binary outcomes.
#' @param K number of classes (integer)
#' @param data an NxJ matrix of multivariate binary responses, where
#'   N is the number of individuals, and J is the number of granular items
#' @param item_membership_list a list of G elements, where the g-th element contains the column
#'  indices of `data` corresponding to items in major group g, and G is number of major item groups
#' @param total_iters number of posterior samples to collect (integer)
#'
#' @param initials a named list of initial values of the following parameters:
#' \describe{
out <- roc_proc_text(rd_roclet(), "
#' @description Use DDT-LCM to estimate latent class and tree on class profiles for
#'  multivariate binary outcomes.
#' @param K number of classes (integer)
#' @param data an NxJ matrix of multivariate binary responses, where
#'   N is the number of individuals, and J is the number of granular items
#' @param item_membership_list a list of G elements, where the g-th element contains the column
#'  indices of `data` corresponding to items in major group g, and G is number of major item groups
#' @param total_iters number of posterior samples to collect (integer)
#'
#' @param initials a named list of initial values of the following parameters:
#' \\describe{
#' \\item{`tree_phylo4d`}{a phylo4d object. The initial tree have K leaves (labeled as "v1" through "vK"),
out <- roc_proc_text(rd_roclet(), "
#' {pkgname}: Playing with Braces
#'
#' Plain-text math: integer in {1, 2, ..., n}, (-1)^{n-1}
#' @md
null <- function () NULL
")[[1]]
out <- roc_proc_text(rd_roclet(), "
#' @description Use DDT-LCM to estimate latent class and tree on class profiles for
#'  multivariate binary outcomes.
#' @param K number of classes (integer)
#' @param data an NxJ matrix of multivariate binary responses, where
#'   N is the number of individuals, and J is the number of granular items
#' @param item_membership_list a list of G elements, where the g-th element contains the column
#'  indices of `data` corresponding to items in major group g, and G is number of major item groups
#' @param total_iters number of posterior samples to collect (integer)
#'
#' @param initials a named list of initial values of the following parameters:
#' \\describe{
#' \\item{`tree_phylo4d`}{a phylo4d object. The initial tree have K leaves (labeled as \"v1\" through \"vK\"),
#'  1 singleton root node (labeled as \"u1\"), and K-1 internal nodes (labeled as \"u1\" through \"u\\_{K-1}\").
#'  The tree also contains parameters for the leaf nodes and the root node (which
#'  equals 0). The parameters for the internal nodes can be NAs because they will not be used in the
#'  algorithm.}
#' \\item{`response_prob`}{a K by J matrix with entries between 0 and 1. The initial values for the
#'  item response probabilities. They should equal to the expit-transformed leaf parameters of `tree_phylo4d`.}
#' \\item{`class_probability`}{a K-vector with entries between 0 and 1. The initial values for the class
#'  probabilities. Entries should be nonzero and sum up to 1, or otherwise will be normalized}
#' \\item{`class_assignments`}{a N-vector with integer entries from {1, ..., K}. The initial values for
#'  individual class assignments.}
#' \\item{`Sigma_by_group`}{a G-vector greater than 0. The initial values for the group-specific diffusion
#'  variances.}
#' \\item{`c`}{a value greater than 0. The initial values for the group-specific diffusion
#'  variances.}
#' }
#' Parameters not supplied with initial values will be initialized using the \\code{initialize} function
#'  with arguments in `initialize_args`.
#'
#'@param priors a named list of values of hyperparameters of priors. See the function
#'  \\code{initialize} for explanation.
#' \\describe{
#' \\item{`shape_sigma`}{a G-vector of positive values. The g-th element is the shape parameter for the
#'  inverse-Gamma prior on diffusion variance parameter sigma_g^2. Default is rep(2, G).}
#' \\item{`rate_sigma`}{a G-vector of positive values. Rate parameter. See above. Default is rep(2, G).}
#' \\item{`prior_dirichlet`}{a K-vector with entries positive entries. The parameter of the Dirichlet prior
#'  on class probability.}
#' \\item{`shape_c`}{a positive value. The shape parameter for the Gamma prior on divergence function
#'  hyperparameter `c`. Default is 1.}
#' \\item{`rate_c`}{a positive value. The rate parameter for `c`. Default is 1.}
#' \\item{`a_pg`}{a positive value. The scale parameter for the generalized logistic distribution used in
#'  the augmented Gibbs sampler for leaf parameters. Default is 1, corresponding to the standard logistic
#'  distribution.}
#' }
#'
#'@param controls a named list of control variables.
#' \\describe{
#' \\item{`fix_tree`}{a logical. If `TRUE` (default), the tree structure will be sampled in the algorithm. If `FALSE`,
#'  the tree structure will be fixed at the initial input.}
#' \\item{`c_order`}{a numeric value. If `1`, the divergence function is a(t) = c/(1-t). If `2`, the divergence
#' function is a(t) = c/(1-t)^2.}
#' }
#'
#'@param initialize_args a named list of initialization arguments. See the function
#'  \\code{initialize} for explanation.
#'
#' @return an object of class \"ddt_lcm\"; a list containing the following elements:
#' \\describe{
#' \\item{`tree_samples`}{a list of information of the tree collected from the sampling algorithm, including:
#'  `accept`: a binary vector where `1` indicates acceptance of the proposal tree and `0` indicates rejection.
#'  `tree_list`: a list of posterior samples of the tree.
#'  `dist_mat_list`: a list of tree-structured covariance matrices representing the marginal covariances
#'  among the leaf parameters, integrating out the internal node parameters and all intermediate stochastic paths
#'  in the DDT branching process.}
#' \\item{`response_probs_samples`}{a `total_iters` x `K` x `J` array of posterior samples of item response probabilities}
#' \\item{`class_probs_samples`}{a `K` x `total_iters` matrix of posterior samples of class probabilities}
#' \\item{`Z_samples`}{a `N` x `total_iters` integer matrix of posterior samples of individual class assignments}
#' \\item{`Sigma_by_group_samples`}{a `G` x `total_iters` matrix of posterior samples of diffusion variances}
#' \\item{`c_samples`}{a `total_iters` vector of posterior samples of divergence function hyperparameter}
#' \\item{`loglikelihood`}{a `total_iters` vector of log-likelihoods of the full model}
#' \\item{`loglikelihood_lcm`}{a `total_iters` vector of log-likelihoods of the LCM model only}
#' \\item{`setting`}{a list of model setup information, including: `K`, `item_membership_list`, and `G`}
#' \\item{`controls`}{a list of model controls, including:
#'  `fix_tree`: FALSE to perform MH sampling of the tree, TRUE to fix the tree at the initial input.
#'  `c_order`: a numeric value of `1` or `2` (see Arguments))}
#' \\item{`data`}{the input data matrix}
#' }
#'
#'@examples
#'# load the MAP tree structure obtained from the real HCHS/SOL data
#'data(data_synthetic)
#'# extract elements into the global environment
#'list2env(setNames(data_synthetic, names(data_synthetic)), envir = globalenv())
#'# run DDT-LCM
#'result <- ddtlcm_fit(K = 3, data = response_matrix, item_membership_list, total_iters = 50)
#'@export
")[[1]]
out <- roc_proc_text(rd_roclet(), "
#' @description Use DDT-LCM to estimate latent class and tree on class profiles for
#'  multivariate binary outcomes.
#' @param K number of classes (integer)
#' @param data an NxJ matrix of multivariate binary responses, where
#'   N is the number of individuals, and J is the number of granular items
#' @param item_membership_list a list of G elements, where the g-th element contains the column
#'  indices of `data` corresponding to items in major group g, and G is number of major item groups
#' @param total_iters number of posterior samples to collect (integer)
#'
#' @param initials a named list of initial values of the following parameters:
#' \\describe{
#' \\item{`tree_phylo4d`}{a phylo4d object. The initial tree have K leaves (labeled as \"v1\" through \"vK\"),
#'  1 singleton root node (labeled as \"u1\"), and K-1 internal nodes (labeled as \"u1\" through \"u\\_{K-1}\").
#'  The tree also contains parameters for the leaf nodes and the root node (which
#'  equals 0). The parameters for the internal nodes can be NAs because they will not be used in the
#'  algorithm.}
#' \\item{`response_prob`}{a K by J matrix with entries between 0 and 1. The initial values for the
#'  item response probabilities. They should equal to the expit-transformed leaf parameters of `tree_phylo4d`.}
#' \\item{`class_probability`}{a K-vector with entries between 0 and 1. The initial values for the class
#'  probabilities. Entries should be nonzero and sum up to 1, or otherwise will be normalized}
#' \\item{`class_assignments`}{a N-vector with integer entries from {1, ..., K}. The initial values for
#'  individual class assignments.}
#' \\item{`Sigma_by_group`}{a G-vector greater than 0. The initial values for the group-specific diffusion
#'  variances.}
#' \\item{`c`}{a value greater than 0. The initial values for the group-specific diffusion
#'  variances.}
#' }
#' Parameters not supplied with initial values will be initialized using the \\code{initialize} function
#'  with arguments in `initialize_args`.
#'
#'@param priors a named list of values of hyperparameters of priors. See the function
#'  \\code{initialize} for explanation.
#' \\describe{
#' \\item{`shape_sigma`}{a G-vector of positive values. The g-th element is the shape parameter for the
#'  inverse-Gamma prior on diffusion variance parameter sigma_g^2. Default is rep(2, G).}
#' \\item{`rate_sigma`}{a G-vector of positive values. Rate parameter. See above. Default is rep(2, G).}
#' \\item{`prior_dirichlet`}{a K-vector with entries positive entries. The parameter of the Dirichlet prior
#'  on class probability.}
#' \\item{`shape_c`}{a positive value. The shape parameter for the Gamma prior on divergence function
#'  hyperparameter `c`. Default is 1.}
#' \\item{`rate_c`}{a positive value. The rate parameter for `c`. Default is 1.}
#' \\item{`a_pg`}{a positive value. The scale parameter for the generalized logistic distribution used in
#'  the augmented Gibbs sampler for leaf parameters. Default is 1, corresponding to the standard logistic
#'  distribution.}
#' }
#' }
")[[1]]
out <- roc_proc_text(rd_roclet(), "
#' @description Use DDT-LCM to estimate latent class and tree on class profiles for
#'  multivariate binary outcomes.
#' @param K number of classes (integer)
#' @param data an NxJ matrix of multivariate binary responses, where
#'   N is the number of individuals, and J is the number of granular items
#' @param item_membership_list a list of G elements, where the g-th element contains the column
#'  indices of `data` corresponding to items in major group g, and G is number of major item groups
#' @param total_iters number of posterior samples to collect (integer)
#'
#' @param initials a named list of initial values of the following parameters:
#' \\describe{
#' \\item{`tree_phylo4d`}{a phylo4d object. The initial tree have K leaves (labeled as \"v1\" through \"vK\"),
#'  1 singleton root node (labeled as \"u1\"), and K-1 internal nodes (labeled as \"u1\" through \"u\\_{K-1}\").
#'  The tree also contains parameters for the leaf nodes and the root node (which
#'  equals 0). The parameters for the internal nodes can be NAs because they will not be used in the
#'  algorithm.}
#' \\item{`response_prob`}{a K by J matrix with entries between 0 and 1. The initial values for the
#'  item response probabilities. They should equal to the expit-transformed leaf parameters of `tree_phylo4d`.}
#' \\item{`class_probability`}{a K-vector with entries between 0 and 1. The initial values for the class
#'  probabilities. Entries should be nonzero and sum up to 1, or otherwise will be normalized}
#' \\item{`class_assignments`}{a N-vector with integer entries from {1, ..., K}. The initial values for
#'  individual class assignments.}
#' \\item{`Sigma_by_group`}{a G-vector greater than 0. The initial values for the group-specific diffusion
#'  variances.}
#' \\item{`c`}{a value greater than 0. The initial values for the group-specific diffusion
#'  variances.}
#' }
#' Parameters not supplied with initial values will be initialized using the \\code{initialize} function
#'  with arguments in `initialize_args`.
")[[1]]
out <- roc_proc_text(rd_roclet(), "
#' @description Use DDT-LCM to estimate latent class and tree on class profiles for
#'  multivariate binary outcomes.
#' @param initials a named list of initial values of the following parameters:
#' \\describe{
#' \\item{`tree_phylo4d`}{a phylo4d object. The initial tree have K leaves (labeled as \"v1\" through \"vK\"),
#'  1 singleton root node (labeled as \"u1\"), and K-1 internal nodes (labeled as \"u1\" through \"u\\_{K-1}\").
#'  The tree also contains parameters for the leaf nodes and the root node (which
#'  equals 0). The parameters for the internal nodes can be NAs because they will not be used in the
#'  algorithm.}
#' \\item{`response_prob`}{a K by J matrix with entries between 0 and 1. The initial values for the
#'  item response probabilities. They should equal to the expit-transformed leaf parameters of `tree_phylo4d`.}
#' \\item{`class_probability`}{a K-vector with entries between 0 and 1. The initial values for the class
#'  probabilities. Entries should be nonzero and sum up to 1, or otherwise will be normalized}
#' \\item{`class_assignments`}{a N-vector with integer entries from {1, ..., K}. The initial values for
#'  individual class assignments.}
#' \\item{`Sigma_by_group`}{a G-vector greater than 0. The initial values for the group-specific diffusion
#'  variances.}
#' \\item{`c`}{a value greater than 0. The initial values for the group-specific diffusion
#'  variances.}
#' }
#' Parameters not supplied with initial values will be initialized using the \\code{initialize} function
#'  with arguments in `initialize_args`.
")[[1]]
out <- roc_proc_text(rd_roclet(), "
#' @description Use DDT-LCM to estimate latent class and tree on class profiles for
")[[1]]
out <- roc_proc_text(rd_roclet(), "
#' @description Use DDT-LCM to estimate latent class and tree on class profiles for
#'  multivariate binary outcomes.
#' @param initials a named list of initial values of the following parameters:
#' \\describe{
#' \\item{`tree_phylo4d`}{a phylo4d object. The initial tree have K leaves (labeled as \"v1\" through \"vK\"),
#'  1 singleton root node (labeled as \"u1\"), and K-1 internal nodes (labeled as \"u1\" through \"u\\_{K-1}\").
#'  The tree also contains parameters for the leaf nodes and the root node (which
#'  equals 0). The parameters for the internal nodes can be NAs because they will not be used in the
#'  algorithm.}
#' \\item{`response_prob`}{a K by J matrix with entries between 0 and 1. The initial values for the
#'  item response probabilities. They should equal to the expit-transformed leaf parameters of `tree_phylo4d`.}
#' \\item{`class_probability`}{a K-vector with entries between 0 and 1. The initial values for the class
#'  probabilities. Entries should be nonzero and sum up to 1, or otherwise will be normalized}
#' \\item{`class_assignments`}{a N-vector with integer entries from {1, ..., K}. The initial values for
#'  individual class assignments.}
#' \\item{`Sigma_by_group`}{a G-vector greater than 0. The initial values for the group-specific diffusion
#'  variances.}
#' \\item{`c`}{a value greater than 0. The initial values for the group-specific diffusion
#'  variances.}
#' }
#' Parameters not supplied with initial values will be initialized using the \\code{initialize} function
#'  with arguments in `initialize_args`.
")
out
out <- roc_proc_text(rd_roclet(), "
#' {pkgname}: Playing with Braces
#'
#' Plain-text math: integer in {1, 2, ..., n}, (-1)^{n-1}
#' @md
null <- function () NULL
")[[1]]
View(out)
out <- roc_proc_text(rd_roclet(), "
#' @description Use DDT-LCM to estimate latent class and tree on class profiles for
#'
#' Plain-text math: integer in {1, 2, ..., n}, (-1)^{n-1}
#' @md
null <- function () NULL
")[[1]]
devtools::build()
library(tools)
devtools::document()
devtools::build()
Rd <- file.path("man/ddtlcm_fit.Rd")
checkRd(Rd)
devtools::document()
devtools::document()
?checkRd
all_Rd_files <- list.files("man")
for (Rd_file in all_Rd_files){
Rd <- file.path("man/ddtlcm_fit.Rd")
checkRd(Rd)
}
checkRd(Rd)
Rd
checkRd(Rd)
devtools::build()
devtools::document()
?simulate_lcm_response
devtools::document()
devtools::document()
devtools::build()
devtools::document()
devtools::build()
devtools::document()
devtools::build()
devtools::document()
devtools::build()
pkgload::dev_help('simulate_lcm_response')
devtools::document()
devtools::build()
